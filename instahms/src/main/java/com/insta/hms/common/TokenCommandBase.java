package com.insta.hms.common;

import org.apache.struts.chain.commands.ActionCommandBase;
import org.apache.struts.chain.contexts.ActionContext;
import org.apache.struts.chain.contexts.ServletActionContext;
import org.apache.struts.util.MessageResources;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.concurrent.Semaphore;

import javax.servlet.http.HttpSession;

/**
 * Class that provides the token management functions for use by the token command classes, included
 * in the struts command chain.
 */

public abstract class TokenCommandBase extends ActionCommandBase {

  /** The Constant TRANSACTION_TOKEN_KEY. */
  public static final String TRANSACTION_TOKEN_KEY = "_insta_transaction_token";

  /** The Constant TRANSACTION_TOKEN_QUEUE_KEY. */
  public static final String TRANSACTION_TOKEN_QUEUE_KEY = "transaction_token_queue";

  /** The Constant REQUEST_LATCH_KEY. */
  private static final String REQUEST_LATCH_KEY = "request_latch";

  /** The Constant MAX_CONCURRENT_REQUESTS_KEY. */
  private static final String MAX_CONCURRENT_REQUESTS_KEY = "max.concurrent.requests";

  /** The Constant REQUEST_LATCH_ARCQUIRED. */
  protected static final String REQUEST_LATCH_ARCQUIRED = "request_latch_acquired";

  /** The log. */
  static Logger log = LoggerFactory.getLogger(TokenCommandBase.class);

  /**
   * Command chain entry point into the command. Casts the ctx to a ServletActionContext and
   * delegates to the subclasses.
   *
   * @param ctx - action context for the current command
   * @return true, if successful
   * @throws Exception the exception
   */
  public boolean execute(ActionContext ctx) throws Exception {
    return execute((ServletActionContext) ctx);
  }

  /**
   * Method to be implemented by the subclasses.
   *
   * @param ctx - ServletActionContext associated with the command
   * @return - true to terminate the command chain - false to continue the command chain
   * @throws Exception the exception
   */
  protected abstract boolean execute(ServletActionContext ctx) throws Exception;

  /**
   * Method to generateToken. Delegates to the ActionContext.generateToken().
   *
   * @param ctx the ctx
   * @return the string
   */
  protected String generateToken(ServletActionContext ctx) {
    String tokenKey = null;
    if (null != ctx) {
      tokenKey = ctx.generateToken();
    }
    return tokenKey;
  }

  /**
   * Generates the token and sets it in the token queue.
   * 
   * @param ctx - ServletActionContext - context for this command
   * @return - String key for the token that was created
   */
  protected synchronized String createToken(ServletActionContext ctx) {
    String tokenKey = generateToken(ctx);
    TokenQueue tokenQ = getTokenQueue(ctx);
    tokenQ.put(tokenKey, new RequestToken(tokenKey));
    return tokenKey;
  }

  /**
   * Releases the lock on the token.
   * 
   * @param ctx   - ServletActionContext - context for this command
   * @param token - RequestToken to be released
   * @return - true if the token was unlocked - false if the token was not unlocked.
   */
  protected boolean releaseToken(ServletActionContext ctx, RequestToken token) {
    if (null != token) {
      token.unlock();
      return true;
    }

    return false;
  }

  /**
   * Retrieves the token with the specified key, from the token queue. Locks the token before
   * returning it. Each call to getToken() should be matched with a call to releaseToken() to
   * realease the lock on the token.
   * 
   * @param ctx      - ServletActionContext - context for this command
   * @param tokenKey - key for which the token should be retrieved
   * @return token retrieved from the queue, if one exists, null otherwise.
   */
  protected RequestToken getToken(ServletActionContext ctx, String tokenKey) {
    RequestToken token = null;
    if (null != tokenKey && !tokenKey.isEmpty()) {
      // get the tokenQ
      TokenQueue tokenQ = getTokenQueue(ctx);
      // get the key from the queue
      if (null != tokenQ) {
        token = (RequestToken) tokenQ.get(tokenKey);
        if (null != token) {
          token.lock();
        }
      }
    }
    return token;
  }

  /**
   * Retrieves the token queue fron the HttpSession if one exists, else creates a TokenQueue and
   * returns the newly created queue.
   * 
   * @param ctx - ServletActionContext - context for this command
   * @return TokenQueue - a queue that holds the transaction tokens generated by the last n requests
   *         where n is &lt;= TokenQueue.TRANSACTON_TOKEN_QUEUE_LENGTH
   */
  private synchronized TokenQueue getTokenQueue(ServletActionContext ctx) {
    HttpSession session = ctx.getRequest().getSession();
    TokenQueue tokenQ = (TokenQueue) session.getAttribute(TRANSACTION_TOKEN_QUEUE_KEY);
    if (null == tokenQ) {
      tokenQ = new TokenQueue();
      session.setAttribute(TRANSACTION_TOKEN_QUEUE_KEY, tokenQ);
    }
    return tokenQ;
  }

  /**
   * Acquire request latch.
   *
   * @param ctx the ctx
   */
  protected void acquireRequestLatch(ServletActionContext ctx) {
    int maxConcurrentRequests = getMaxConcurrentRequests(ctx);
    Semaphore requestLatch = null;
    if (maxConcurrentRequests > 0) {

      HttpSession session = ctx.getRequest().getSession();

      synchronized (session) {
        requestLatch = (Semaphore) session.getAttribute(REQUEST_LATCH_KEY);
        log.debug("-> @acquire " + ((requestLatch == null) ? ""
            : requestLatch.toString().replace("java.util.concurrent.", "")));
        if (null == requestLatch) {
          requestLatch = new Semaphore(maxConcurrentRequests);
          session.setAttribute(REQUEST_LATCH_KEY, requestLatch);
          log.debug("--> %set " + requestLatch.toString().replace("java.util.concurrent.", ""));
        }
      }

      if (null != requestLatch) {
        requestLatch.acquireUninterruptibly();
        ctx.put(REQUEST_LATCH_ARCQUIRED, Boolean.TRUE);
      }

    }

    log.debug("<- @acquire " + ((requestLatch == null) ? ""
        : requestLatch.toString().replace("java.util.concurrent.", "")));
    return;
  }

  /**
   * Release request latch.
   *
   * @param ctx the ctx
   */
  protected void releaseRequestLatch(ServletActionContext ctx) {
    HttpSession session = ctx.getRequest().getSession();
    Semaphore requestLatch = (Semaphore) session.getAttribute(REQUEST_LATCH_KEY);
    log.debug("-> #release " + ((requestLatch == null) ? ""
        : requestLatch.toString().replace("java.util.concurrent.", "")));
    if (null != requestLatch) {
      requestLatch.release();
    }
    log.debug("<- #release " + ((requestLatch == null) ? ""
        : requestLatch.toString().replace("java.util.concurrent.", "")));
    return;
  }

  /**
   * Gets the max concurrent requests.
   *
   * @param ctx the ctx
   * @return the max concurrent requests
   */
  private int getMaxConcurrentRequests(ServletActionContext ctx) {
    Integer maxConcurrentRequests = 0;
    log.debug("Entering getMaxConcurrentRequests... " + maxConcurrentRequests);
    MessageResources resource = ctx.getMessageResources();
    if (null != resource) {
      log.debug("Loading max concurrent requests from resource file...");
      String concurrentRequests = resource.getMessage(MAX_CONCURRENT_REQUESTS_KEY);
      if (null != concurrentRequests) {
        try {
          maxConcurrentRequests = Integer.valueOf(concurrentRequests);
        } catch (NumberFormatException nfe) {
          log.error("Invalid setting in application.properties"
              + " for max.concurrent.requests, ignoring value");
          maxConcurrentRequests = 0;
        }
      }
    }
    log.debug("Exiting getMaxConcurrentRequests... " + maxConcurrentRequests);
    return maxConcurrentRequests;
  }

}
